<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Server - ❄️ Blizzard ❄️</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../roadmap.html"><strong aria-hidden="true">2.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="../getting_started.html"><strong aria-hidden="true">3.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="../server.html"><strong aria-hidden="true">4.</strong> Server Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/connection.html"><strong aria-hidden="true">4.1.</strong> Connection Listener</a></li><li class="chapter-item expanded "><a href="../server/pool.html"><strong aria-hidden="true">4.2.</strong> Pool</a></li><li class="chapter-item expanded "><a href="../server/connector.html"><strong aria-hidden="true">4.3.</strong> Connector</a></li><li class="chapter-item expanded "><a href="../server/controller.html"><strong aria-hidden="true">4.4.</strong> Controller</a></li><li class="chapter-item expanded "><a href="../server/application.html"><strong aria-hidden="true">4.5.</strong> Application</a></li></ol></li><li class="chapter-item expanded "><a href="../engine.html"><strong aria-hidden="true">5.</strong> Engine Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../engine/application.html"><strong aria-hidden="true">5.1.</strong> Application</a></li></ol></li><li class="chapter-item expanded "><a href="../learn.html"><strong aria-hidden="true">6.</strong> Learn</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../learn/world.html"><strong aria-hidden="true">6.1.</strong> World</a></li><li class="chapter-item expanded "><a href="../learn/ec.html"><strong aria-hidden="true">6.2.</strong> Entities and Components</a></li><li class="chapter-item expanded "><a href="../learn/systems.html"><strong aria-hidden="true">6.3.</strong> Systems</a></li><li class="chapter-item expanded "><a href="../learn/game.html"><strong aria-hidden="true">6.4.</strong> Game</a></li><li class="chapter-item expanded "><a href="../learn/server.html" class="active"><strong aria-hidden="true">6.5.</strong> Server</a></li><li class="chapter-item expanded "><a href="../learn/client.html"><strong aria-hidden="true">6.6.</strong> Client</a></li></ol></li><li class="chapter-item expanded "><a href="../origin.html"><strong aria-hidden="true">7.</strong> Origin</a></li><li class="chapter-item expanded "><a href="../dev_process.html"><strong aria-hidden="true">8.</strong> Development Process</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">❄️ Blizzard ❄️</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tcp-server"><a class="header" href="#tcp-server">TCP Server</a></h1>
<p>For now, only TCP servers can be created. To make a server we need to add the following to the top of our <code>server.rs</code> file:</p>
<pre><code>use blizzard_server::server::Server;
use std::sync::mpsc::Receiver;
use std::sync::{Arc, Mutex};
</code></pre>
<p>The top should now look like this:</p>
<pre><code>extern crate blizzard_engine;
extern crate blizzard_engine_derive;

use blizzard_engine::ecs::{ComponentRegistry, EntityManager, World};
use blizzard_engine::game::Game;
use blizzard_engine_derive::ComponentRegistry;
use blizzard_server::server::Server;

use std::collections::HashMap;
use std::sync::mpsc::Receiver;
use std::sync::{Arc, Mutex};
use std::ops::AddAssign;
</code></pre>
<h2 id="make-the-server"><a class="header" href="#make-the-server">Make the server</a></h2>
<p>In the file's <code>main</code> function (or create the function), we will configure our server. We need to define:</p>
<ul>
<li>Port: a port where our server will listen to incoming connections</li>
<li>Max games</li>
<li>Max players per game</li>
<li>The game</li>
<li>Shared state (to send to client)</li>
<li>Client input type</li>
<li>Rate at which data is sent to client (FPS or HZ)</li>
<li>Rate at which the game updates (FPS or HZ)</li>
<li>How to handle client input</li>
</ul>
<p>The server's <code>new</code> function has the following signature:</p>
<pre><code>pub fn new&lt;T: Game&lt;K, I&gt;, K, I, M&gt;(
    port: i32,
    max_games: i32,
    max_players: i32,
    game: T,
    shared_state: K,
    input: I,
    handle_input: &amp;'static (dyn Fn(Receiver&lt;(M, usize)&gt;, Arc&lt;Mutex&lt;I&gt;&gt;) -&gt; I + Sync),
    send_data_rate: i32,
    game_update_rate: i32,
)  ...
</code></pre>
<p>The new type is <code>M</code>, which is a type used for the <code>Message</code>s sent from client to the game.</p>
<p>Let's create our basic configuration:</p>
<pre><code>fn main() {
    let port = 8888;
    let max_games = 4;
    let max_players = 2;
    let world = MyWorld::new();
    let shared_state = SharedState::new();
    let game = new_game(world);

    // The data that a client message will manipulate
    let input_type = Input::default();
    let hanlde_input = &amp;handle_client_message;

    // Engine speeds
    let send_data_from_server_rate = 1;
    let server_game_update_rate = 2; // 2 times per second

    // Start server + games
    Server::new(
        port,
        max_games,
        max_players,
        game,
        shared_state,
        input_type,
        hanlde_input,
        send_data_from_server_rate,
        server_game_update_rate,
    );
}

</code></pre>
<p>We have a couple of missing definitions, let's create them.</p>
<p>Input:</p>
<pre><code>#[derive(Debug, Clone, Copy)]
struct Input(Message, usize);

impl Input {
    fn default() -&gt; Self {
        Self(Message::None, 0)
    }
    fn from(m: Message, id: usize) -&gt; Self {
        Self(m, id)
    }
}
</code></pre>
<p>We are changing the input to contain a <code>Message</code>, and a number of type <code>usize</code>. This second one is for identification, it will be passed by the client to identify the player generating the <code>Input</code>.</p>
<p>Message:</p>
<pre><code>#[derive(Serialize, Deserialize, Clone, Copy, Debug)]
pub enum Message {
    None,
    W,
    A,
    S,
    D,
    AddPlayer,
    RemovePlayer,
}
</code></pre>
<p>SharedState:</p>
<pre><code>#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SharedState {
    pub counters: Vec&lt;u32&gt;,
    pub registry: Vec&lt;Position&gt;,
}

impl SharedState {
    pub fn new() -&gt; Self {
        Self {
            registry: vec![],
            counters: vec![],
        }
    }
}
</code></pre>
<p>The shared state will be to show the counters and the positions of players.</p>
<p>Handle client message:</p>
<pre><code>fn handle_client_message(receiver: Receiver&lt;(Message, usize)&gt;, input: Arc&lt;Mutex&lt;Input&gt;&gt;) -&gt; Input {
    for (message, id) in receiver {
        println!(&quot;Player {} called {:?}&quot;, id, message);
        *input.lock().unwrap() = Input::from(message, id);
    }
    Input::default()
}
</code></pre>
<p>This is an interesting code bit. To handle a client message, when creating the server, an <code>Application</code> is created which wraps the <code>Game</code>, and is in charge for calling the game loop and also connecting all inputs and communications. Hence this function is to handle inputs. It actually handles messages. A <code>Message</code> will be sent from the client. The <code>Receiver</code> will receive the <code>Message</code> and decide what <code>Input</code> to generate based on the message. For now, we are just passing the message on to the <code>Input</code> which will be used in the update_systems function inside the <code>World</code>. The <code>Input</code> is wrapped in a Arc and Mutex.</p>
<h2 id="adding-game-logic"><a class="header" href="#adding-game-logic">Adding game logic</a></h2>
<p>Let's make some systems that will be used.</p>
<p>Adding a player entity, with a player component and position:</p>
<pre><code>fn add_player_system(world: &amp;mut MyWorld, player_id: usize) {
    let ent = world.entity_manager.create_entity();
    world.players.add(ent, player_id);
    world.positions.add(ent, Position::new());
    world.player_id_map.players.insert(player_id, ent);
}
</code></pre>
<p>When a player joins a game, they get a UID defined by the server. However, the <code>World</code> has no way to know which entity belongs to a player. Hence we created the <code>PlayerIdMap</code>:</p>
<pre><code>#[derive(Debug, Clone)]
struct MyWorld {
    entity_manager: EntityManager,
    positions: PositionRegistry,
    counters: CounterRegistry,
    players: PlayerRegistry,
    player_id_map: PlayerIdMap,
}

impl World&lt;Input&gt; for MyWorld {
    fn new() -&gt; Self {
        Self {
            entity_manager: EntityManager::new(),
            positions: PositionRegistry::new(),
            counters: CounterRegistry::new(),
            players: PlayerRegistry::new(),
            player_id_map: PlayerIdMap::new(),
        }
    }
    fn run_systems(&amp;mut self, input: Input) {
        ...
    }
}

#[derive(Debug, Clone)]
struct PlayerIdMap {
    players: HashMap&lt;usize, u32&gt;,
}
impl PlayerIdMap {
    fn new() -&gt; Self {
        Self {
            players: HashMap::new(),
        }
    }
}
</code></pre>
<p>Updating player position system:</p>
<pre><code>fn update_player_pos_system(world: &amp;mut MyWorld, player_id: usize, displacement: Position) {
    if let Some(ent) = world.player_id_map.players.get(&amp;player_id) {
        *world
            .positions
            .components
            .entry(*ent)
            .or_insert(displacement) += displacement;
    }
}
</code></pre>
<p>Removing a player system:</p>
<pre><code>fn remove_player_system(world: &amp;mut MyWorld, player_id: usize) {
    if let Some(ent) = world.player_id_map.players.get(&amp;player_id) {
        world.players.components.remove(ent);
        world.positions.components.remove(ent);
        world.entity_manager.remove_entity(*ent);
        world.player_id_map.players.remove(&amp;player_id);
    }
}
</code></pre>
<h2 id="updating-games-using-run_systems-and-input"><a class="header" href="#updating-games-using-run_systems-and-input">Updating games using run_systems and input</a></h2>
<p>We can now do a lot of basic functionality using this. Let's add our systems to our run_systems:</p>
<pre><code>fn run_systems(&amp;mut self, input: Input) {
        // Systems to run conditionally
        match input.0 {
            Message::AddPlayer =&gt; add_player_system(self, input.1),
            Message::W =&gt; {
                update_player_pos_system(self, input.1, Position::displacement(0, 1));
            }
            Message::A =&gt; {
                update_player_pos_system(self, input.1, Position::displacement(-1, 0));
            }
            Message::S =&gt; {
                update_player_pos_system(self, input.1, Position::displacement(0, -1));
            }
            Message::D =&gt; {
                update_player_pos_system(self, input.1, Position::displacement(1, 0));
            }
            Message::RemovePlayer =&gt; {
                remove_player_system(self, input.1);
            }
            _ =&gt; {}
        }
        // Systems to always run
        counter_system(&amp;mut self.counters.components);
    }
</code></pre>
<h2 id="defining-the-data-to-be-sent-to-the-client"><a class="header" href="#defining-the-data-to-be-sent-to-the-client">Defining the data to be sent to the client</a></h2>
<p>Inside the <code>Game</code>'s update function, we can now copy the desired data over to the <code>SharedState</code>, which is sent off to the client:</p>
<pre><code>fn update(&amp;mut self, input: Input, shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;) {
        // Update states
        self.world.run_systems(input);
        self.counter += 1;

        // Update shared state: for client reception
        shared_state.lock().unwrap().counters = self
            .world
            .counters
            .components
            .iter()
            .map(|(_, counter)| *counter)
            .collect();

        shared_state.lock().unwrap().registry = self
            .world
            .positions
            .components
            .iter()
            .map(|(_, positions)| *positions)
            .collect();
}
</code></pre>
<p>Here we are just copying the data from the counter and position components into vectors of information.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>This is everything! You have created your own multiplayer game server! You can start the server in your terminal by typing:</p>
<pre><code>cargo run --bin server
</code></pre>
<p>You will see a couple of logs from the server. However nothing exciting really happens. This is because there are no players connecting to any games! Let's now write a client that connects to a game. We will be writing the client inside the <code>client.rs</code> file. However, now we will use the library we created, <code>my_game</code>. The library is a suggestion, because many of the client's data structs are the same as the game's. For example:</p>
<ul>
<li><code>Message</code></li>
<li><code>SharedState</code></li>
<li><code>Position</code></li>
</ul>
<p>Let's write a client that connects to our server.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../learn/game.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../learn/client.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../learn/game.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../learn/client.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
